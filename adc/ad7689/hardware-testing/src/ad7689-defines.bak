#include <SPI.h>		// include the new SPI library:

#define INCC_BIPOLAR_DIFF     0b000 // 00X
#define INCC_BIPOLAR_COM      0b010
#define INCC_TEMP             0b011
#define INCC_UNIPOLAR_DIFF    0b100 // 10X
#define INCC_UNIPOLAR_REF_COM 0b110
#define INCC_UNIPOLAR_REF_GND 0b111

#define INT_REF_25            0b000
#define INT_REF_4096          0b001
#define EXT_REF_TEMP_ON       0b010
#define EXT_REF_TEMP_BUF      0b011
#define EXT_REF_TEMP_OFF      0b110
#define EXT_REF_TEMP_OFF_BUF  0b111

#define SEQ_OFF               0b00
#define SEQ_UPDATE            0b01
#define SEQ_SCAN_INPUT_TEMP   0b10
#define SEQ_SCAN_INPUT        0b11



//void set_AD7689 (uint8_t);
uint16_t read_AD7689 ();
float readVoltage(float ref);
void setConfig(uint8_t, uint8_t, bool, uint8_t, uint8_t);

void setup ()
{
  // initialize SPI:
  SPI.begin ();
  //delay(1000);
  //set_AD7689(7); // set channel
  setConfig(INCC_UNIPOLAR_REF_GND, 6, 0, INT_REF_25, SEQ_OFF);
  Serial.begin(115200);
}

void loop ()
{
//  delayMicroseconds(200);
  //Serial.println(read_AD7689());            // read value with precise capture time
  Serial.println(readVoltage(2.5));
  delay(200);

} // loop()


//*************************************************

// AD7689 16 bit SPI A/D converter interface
// Supports highly accurate sample time
#define AD7689_PIN 10		// chip select pin to use (10 is standard)
#define AD_DELAY   6    // delay from datasheet, default 6 Âµs

// set up the speed, mode and endianness of each device
// MODE0: SCLK idle low (CPOL=0), MOSI read on rising edge (CPHI=0)
SPISettings AD7689_settings (10000000, MSBFIRST, SPI_MODE0);

// Note: use CPHA = CPOL = 0
// Note: two dummy conversions are required on startup
static uint16_t ad7689_config = 0;
/*
void set_AD7689 (uint8_t channel) {

  // bit shifts needed for config register values, from datasheet p. 27 table 11:
  #define CFG 13
  #define INCC 10
  #define INx 7
  #define BW  6
  #define REF 3
  #define SEQ 1
  #define RB 0

  // mask 8 bit input channel to 4 bit input channel
  channel = channel & 0x0F;

  // select channel and other config
  ad7689_config = 0;
  ad7689_config |= 1 << CFG;		// update config on chip
  ad7689_config |= 0B111 << INCC;	// mode - single ended, differential, ref, etc
  ad7689_config |= channel << INx;	// channel
  ad7689_config |= 0 << BW;		// 1 adds more filtering
  ad7689_config |= 0b001 << REF; // internal 4.096V reference
  //ad7689_config |= 0B0 << REF;	// use internal 2.5V reference
  //ad7689_config |= 0B110 << REF;	// use external reference (maybe ~3.3V)
  ad7689_config |= 0 << SEQ;		// don't auto sequence
  ad7689_config |= 0 << RB;		// don't read back config value

  ad7689_config = ad7689_config << 2;   // convert 14 bits to 16 bits

  pinMode (AD7689_PIN, OUTPUT);      // set the Slave Select Pin as output

  SPI.beginTransaction (AD7689_settings);

  // send config (RAC mode)
  digitalWrite (AD7689_PIN, LOW);
  SPI.transfer (ad7689_config >> 8);	// high byte
  SPI.transfer (ad7689_config & 0xFF);	// low byte, 2 bits ignored
  digitalWrite (AD7689_PIN, HIGH);
  delayMicroseconds(AD_DELAY);

  // dummy
  digitalWrite (AD7689_PIN, LOW);
  SPI.transfer (ad7689_config >> 8);	// high byte
  SPI.transfer (ad7689_config & 0xFF);	// low byte, 2 bits ignored
  digitalWrite (AD7689_PIN, HIGH);
  delayMicroseconds(AD_DELAY);

  SPI.endTransaction ();

}
*/
void setConfig(uint8_t chconf, uint8_t channel, bool bandwidth, uint8_t refsource, uint8_t sequencer) {

  // bit shifts needed for config register values, from datasheet p. 27 table 11:
  #define CFG 13
  #define INCC 10
  #define INx 7
  #define BW  6
  #define REF 3
  #define SEQ 1
  #define RB 0

  // select channel and other config
  ad7689_config = 0;
  ad7689_config |= 1 << CFG;		// update config on chip
  ad7689_config |= (chconf & 0b111) << INCC;	// mode - single ended, differential, ref, etc
  ad7689_config |= (channel & 0b111) << INx;	// channel
  ad7689_config |= bandwidth << BW;		// 1 adds more filtering
  ad7689_config |= (refsource & 0b111) << REF; // internal 4.096V reference
  //ad7689_config |= 0B0 << REF;	// use internal 2.5V reference
  //ad7689_config |= 0B110 << REF;	// use external reference (maybe ~3.3V)
  ad7689_config |= (sequencer & 0b11) << SEQ;		// don't auto sequence
  ad7689_config |= 0 << RB;		// don't read back config value

  ad7689_config = ad7689_config << 2;   // convert 14 bits to 16 bits

  pinMode(AD7689_PIN, OUTPUT);      // set the Slave Select Pin as output

  SPI.beginTransaction(AD7689_settings);

  // send config (RAC mode)
  // send twice for dummy conversion
  for (int i = 0; i < 2; i++) {
    digitalWrite(AD7689_PIN, LOW);
    SPI.transfer(ad7689_config >> 8);	// high byte
    SPI.transfer(ad7689_config & 0xFF);	// low byte, 2 bits ignored
    digitalWrite(AD7689_PIN, HIGH);
    delayMicroseconds(AD_DELAY);
    }

/*
  // dummy
  digitalWrite(AD7689_PIN, LOW);
  SPI.transfer(ad7689_config >> 8);	// high byte
  SPI.transfer(ad7689_config & 0xFF);	// low byte, 2 bits ignored
  digitalWrite(AD7689_PIN, HIGH);
  delayMicroseconds(AD_DELAY);
*/
  SPI.endTransaction ();

}

// do conversion and return result
// assume that the channel is already set correctly
// sample & hold and conversion starts immediately

//inline uint16_t read_AD7689() __attribute__((always_inline));

uint16_t read_AD7689 ()
{

  // do conversion
  digitalWrite(AD7689_PIN, LOW);         // chip select
  digitalWrite(AD7689_PIN, HIGH);        // chip deselect  (starts conversion)
  delayMicroseconds(AD_DELAY);                      // wait till complete

  // read conversion result
  SPI.beginTransaction (AD7689_settings);
  digitalWrite (AD7689_PIN, LOW);            // chip select
  uint16_t val = SPI.transfer (ad7689_config  >> 8) << 8;   // high byte
  val |= SPI.transfer (ad7689_config);	    // low byte
  digitalWrite (AD7689_PIN, HIGH);          // chip select
  delayMicroseconds(AD_DELAY);                     // wait for second conversion to complete
  SPI.endTransaction ();

  return val;
}

float readVoltage(float ref){
  return (read_AD7689() * ref / 65536);
}
